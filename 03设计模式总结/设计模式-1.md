设计模式： 

> 设计模式是指在**软件开发过程**中，**经过验证的**，用于解决在**特定环境**下，**重复出现**的，**特定问题**的解决方案。

理解C++的内存模型（继承和组合）
下面是继承的例子：

```cpp
class Subject : public Base  
{
};
```
组合的例子

```cpp
class Subject
{
private:
	Base base;
};

// 第二种组合例子
class Subject
{
private:
	Base* base;
};
```
下面是上面中的例子在内存中的情况：
继承和使用对象进行组合在内存中的情况是分布在一起的，使用指针进行组合，可以子类和父类指针分开，从而可以实现运行时的多态（也叫**晚绑定**）
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210223210133123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDg2MDI3,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210223210144597.png)
下面是虚函数的例子，通过虚函数表可以更加清楚的看到子类函数对父类函数的覆盖。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210223210443780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDg2MDI3,size_16,color_FFFFFF,t_70)
ps:在c语言中nginx 和redis 中是通过**函数指针的形式实现多态**。

## 模式设计的原则：（重点）
1. 依赖倒置原则

> 	高层模块不应该依赖低层模块，二者都应该依赖**抽象**。 	
> 抽象不应该依赖具体实现，具体实现应该依赖于抽象。

2. 开放封闭原则
>一个类应该对**扩展开放**，对**修改关闭**。
3. 面向接口编程
> 不将变量类型声明为某个特定的具体类，而是声明为某个接口。
> 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。
> 减少系统中各部分的依赖关系，从而实现**高内聚，松耦合**的类型设计方案。
4. 封装变化点  （工厂模式，代理模式，适配器模式等）
> 将稳定点和变换点分离，扩展修改变换点；让**稳定点**与**变化点**的实现层次分离。
5. 单一职责原则
> 一个类应该仅有一个引起它变化的原因。
6. 里氏替换原则
> 子类型必须能够替换它的父类型；主要出现在子类覆盖父类实现，原来使用父类型的程序可能出现错误，覆盖了父类方法却没实现父类方法的职责；
7. 接口隔离原则（public， private， protected 的区别）
> 不应该强迫客户依赖于他们不用的方法；
> 一般用于处理一个类拥有比较多的接口，而这些接口涉及到很多职责。
8. 对象组合优于继承
> 继承**耦合度高**，组合耦合度低。

设计模式是找出稳定点，就像skynet，nginx服务器框架，做业务开发的时候，就是框架是稳定点，业务是变化点，业务跟着稳定点变化；如果业务全部都是变换点，这时候就用不到设计模式了，在游戏开发中，像全部变换的点，需要用**脚本语言**去完成，就是这样的道理。

设计模式重点是将业务抽象出来，然后将稳定点封装起来。
经典的例子就是: 一个人喜欢养猫，但是又爱干净。于是就需要想办法，结果是将猫放在指定的笼子（位置中）。这样就隔离，实现上面两种目的。
