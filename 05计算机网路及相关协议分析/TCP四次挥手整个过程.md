tcp报文图示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401205322358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDg2MDI3,size_16,color_FFFFFF,t_70)
 **序列号seq**：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。
**确认号ack**：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。
**确认ACK**：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效
**同步SYN**：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。
**终止FIN**：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接
>PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。

| 字段 |	含义 |
| --- | ---|
| URG |	紧急指针是否有效。为1，表示某一位需要被优先处理
|ACK|	确认号是否有效，一般置为1。
PSH	|提示接收端应用程序立即从TCP缓冲区把数据读走。
RST|	对方要求重新建立连接，复位。
SYN	|请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1
FIN |   	希望断开连接。




TCP四次挥手过程理解：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401164438402.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDg2MDI3,size_16,color_FFFFFF,t_70)
1）客户端进程**发出**连接**释放报文**，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN_WAIT_1（终止等待1）状态。 **TCP规定，FIN报文段即使不携带数据，也要消耗一个序号**。
2）服务器**收到**连接**释放报文**，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE_WAIT（**关闭等待**）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE_WAIT状态(**这个状态面试容易提问**)持续的时间。
3) 客户端收到服务器的确认请求后，此时，客户端就进入FIN_WAIT_2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据,版关闭状态，skynet 就支持这种半关闭状态，redis，nginx， memeched均不支持）。
4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST_ACK（最后确认）状态，等待客户端的确认。
5) 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME_WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2MSL（报文最大生存时间）（有的是2分钟，有的30s,1s等）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6) 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

高频面试题：
1. 为什么连接的时候是三次握手，关闭的时候却是四次握手？

>答：因为当Server 端收到Client 端的SYN连接请求报文后，可以直接发送SNYN+ACK
>报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭Socket，所以只能先回复一个ACK报文，告诉Client端，“你发的FIN报文我收到了”。只有等到Server端的所有报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四步挥手。

2. 为什么TIME_WAIT 状态需要经过2MSL（最大报文段生存时间）才能返回Close状态？
> 答：虽按照道理，四个报文发送完毕，我们可以直接进入Close状态，但是我们必须假象网路是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。

ps：2MSL就是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

3. 为什么不饿能两次握手进行连接？
>答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。
**现在把三次握手改成仅需要两次握手**，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

4. 如果已经建立了连接，但是客户端突然出现了故障了怎么办？
> TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

5. CLOSE_WAIT状态是那一端的，如果有大量的CLOSE_WAIT的后果是什么？

>答：上面这个状态是**客户端主动关闭的**，Client端会出现TIME_WAIT状态，**Server端会出现CLOSE_WAIT状态**；如果是服务端主动关闭连接，就会是Server端出现TIME_WAIT, Client出现CLOSE_WAIT状态。（这里主要分析CLOSE_WAIT状态在Server端的情况）

因为Linux分配给一个用户的文件句柄是有限的，而TIME_WAIT和CLOSE_WAIT两种状态如果一直被保持，那么意味着对应数目的通道就一直被占着，而且是“占着茅坑不使劲”，一旦达到句柄数上限，新的请求就无法被处理了，接着就是大量Too Many Open Files异常，tomcat崩溃。。。

> 1. 服务器保持了大量CLOSE_WAIT状态
> TIME_WAIT状态可以通过优化服务器参数得到解决，因为发生TIME_WAIT的情况是服务器自己可控的.，出现大量close_wait的后果是占用系统内存，连接数会满，会出现too many files. 
> **原因分析：** 在服务器与客户端通信过程中，因服务器发生了socket 未关导致的close_wait发生，致使监听port打开的句柄数到了1024个，且均处于close_wait状态，最终造成配置的port 被占满出现 too many files, 无法在进行通信。
>**场景：** 服务器A是一台爬虫服务器，它使用简单的HttpClient去请求资源服务器B上面的apache获取文件资源，正常情况下，如果请求成功，那么在抓取完资源后，服务器A会主动发出关闭连接的请求，这个时候就是主动关闭连接，服务器A的连接状态我们可以看到是TIME_WAIT。如果一旦发生异常呢？假设请求的资源服务器B上并不存在，那么这个时候就会由服务器B发出关闭连接的请求，服务器A就是被动的关闭了连接，如果服务器A被动关闭连接之后程序员忘了让HttpClient释放连接，那就会造成CLOSE_WAIT的状态了。
> 所以**出现将大量CLOSE_WAIT的解决办法**总结为一句话那就是：查代码。因为问题出在服务器程序里头啊。
