#include<iostream>
#include <functional>
#include <algorithm>
#include <vector>
using namespace std;


void ass(int i)
{
	cout << i << " ";
}

int main()
{
	// 匿名函数，  （参数）-> 返回值  ｛函数体｝
	auto f = [](int a)->int {
		return a + 2;
	};
	cout << f(1) << endl;   // 3

	// 特点
	/*
	1. 匿名函数，可以理解为可调用的代码单元，可以理解成为未命名的内联函数
	2. 它也有一个返回类型分，一个参数列表，一个函数体
	3. 与函数不用的是，匿名函数可以在函数内部定义，其他函数是做不到的

	// 格式
	1. [捕捉类型](参数列表)->返回类型 {函数体};
	这时一个返回类型后置的语法，因为匿名函数返回值特别明显，很多时候匿名函数的返回类型可以省略
	2. 参数列表中的参数可以有默认值
	3. 有可能出现编译器推断不出来返回类型，能写返回类型的话尽量写出来
	4. 没有参数，参数列表可以省略， () 也可以不要

	注意：
	1. 捕获列表和函数体 不能省略
	2. lambda调用方法和普通函数相同，都是使用() 这种函数调用运算符
	3. lambda 表达式可以不返回任何类型，不返回任何类型就是void
	auto f = []{};

	捕获列表  []  里面的东西 ：通过捕获列表捕获一定范围内的变量，
	1. []  不捕获任何变量， 但不包括静态局部变量， lammbda函数体内可以直接使用局部静态变量
	int a = 2;
	static int b = 4;
	[] {
		cout << b << endl;   // 正常
		return a;     // 无法捕获变量a
	} ();
	2. [&] 捕获外部作用域中所有变量，并作为引用在函数体内使用
	int a = 2;
	static int b = 4;
	[&] {
		a++;  // 这里也可以改变a的值
		return a;     // 正确
	} ();
	3. [=] : 捕获外部作用域中所有变量，并作为副本（按值）在函数中使用，也就是可以用它的值，但不可以赋值。
	int a = 2;
	static int b = 4;
	[=] {
		a++;	// 这里无法改变a的值
		return a;
	} ();
	4. [this] : 一般用于类中，捕获当前类中this 指针，让lambda 表达式有和当前类成员函数同样的访问权限。
	// 如果[] 中使用的& 或者 = ，那么默认就已经使用this，《捕获this的目的就是为了在lambda中使用当前类的成员函数和成员变量》

	5.[变量名] : 如果是多个变量名，则彼此之间用，分隔。 [变量名] 表示按值捕获变量名代表的变量，同时不捕获其他变量。
	[&变量名] ： 按照引用捕获变量名，同时不捕获其他变量。

	6. [=， &变量名] ： 按值捕获所有变量，但按引用捕获&中所指定的变量，这里的=必须卸载开头。
	开头这个位置表示默认的捕获方式
	捕获列表： 第一个位置是默认的捕获方式（隐式捕获方式）,后续的其他都是显示捕获方式。

	7. [&, 变量名] ： 按引用捕获所有外部变量，但按值捕获后面的变量名，& 必须写在开头

	*/
	// 总结：lambda 表达式对于能访问的外部变量控制是非常细致。

	auto f2 = []() {return 1; };
	auto f3 = [] {return 2; };
	cout << f2() << endl;
	cout << f3() << endl;

	//int a = 2;
	//static int b = 4;
	//[=] {
	//	a++;
	//	return a;     // 无法捕获变量a 
	//} ();

	//==========================================================================================================
	// lambada 表达式延迟调用容易出错细节
	/*
	int x = 3;
	auto f4 = [=] {
		return x;
	};
	x = 10;
	cout << f4() << endl;  // 认为是10 ，实际上是3
	1. 当遇到auto 这里，就是在捕获的这一刻， x的值就已经被赋值到这个f4 中了，
	凡事按值捕获的外部变量，在lambda 表达式定义的这个时刻，所有的外部变量值就被复制了一份存储在lambda表达式变量中。
	静态变量不是被捕获的外部变量
	解决办法： 需要修改， 将= 换成 & 即可.

	*/

	//==========================================================================================================
	//lambda表达式中的mutable(易变的)
	/*
	int x = 3;
	auto f4 = [=]() mutable{
		x = 6;     // 原本是按值捕获的，不能修改，加上mutable后，就可以修改了
		return x;
	};
	*/

	//==========================================================================================================
	/*
	lambda 表达式的类型存储
	c++11中lambda表达式的类型被称呼为“闭包类型（Closure Type)”
	闭包“ 函数内的函数（可调用对象）。本质上就是lambda表达式创建的运行时期的对象；
	可以认为下面的f4 就是一个闭包
	int x = 3;
	auto f4 = [=]() mutable{
		x = 6;
		return x;
	};
	lambda 表达式是一种比较特殊的，匿名的，类类型【闭包类】的对象（也就是定义了一个类类型，又生成了一个匿名的该类类型的对象）
	可以认为是一个带有operator() 的类类型对象， 也就是仿函数（函数对象）
	因此， 也可以用std::function 和 std::bind 来保存和调用lambda 表达式
	std::function<int(int)> f5 = [](int c) {return c; };
	cout << f5(15) << endl;

	std::function<int(int)> f6 = std::bind(  // bind 第一个参数是函数指针， 第二参数开始就是真正的函数参数
		[](int v) {
		return v;
	}, 17
	);
	cout << f6(15) << endl;  // 这里不管给什么参数 ，输出的都是17， 因为内部已经定义了，但是不能不给参数
	每个lambda 都会触发编译器生成一个独一无二的类类型。

	lambda 表达式这种语法，是我们可以就地定义的匿名函数（就地封装短小的功能闭包）

	*/

	//==========================================================================================================
	/*
	不捕获任何变量的lambda 表达式，也是捕获列表为空，可以转换成一个普通的函数指针
	using functype = int(*)(int);  // 定义一个函数指针类型
	functype fp = [](int v) {return v; };
	cout << fp(99) << endl;   // 99

	*/

	//==========================================================================================================
	/*
	lambda 表达式演示和优点总结
	1. for_each简介： 是个函数模版  #include <algorithm>
	void ass(int i)
	{
		cout << i << " ";
	}

	vector<int> mv = { 1,2,3,4,5,6,7,8, 9, 10};
	//for_each(mv.begin(), mv.end(), ass);  //ass函数中必须要 参数
	int re = 0;
	for_each(mv.begin(), mv.end(), [&re](int i) {
		cout << i << " ";
		re += i;
	});
	cout << re << endl;


	2. find_if 简介 ： 函数模版   #include <algorithm>
	用来查找什么东西，取决于它的第三个参数，它的第三个参数也是函数对象（lambda表达式）
	vector<int> mv2 = { 1,2,3,4,5,6,7,8, 9, 10 };
	auto re2 = find_if(mv.begin(), mv.end(), [](int v) {
		cout << v << endl;
		if (v > 4) return true;  // 返回true，停止遍历
		return false;   // 只要返回fasle，那么find_if 就不停的遍历mv2 ，一直到返回true 或者遍历结束为止。
	});   //out : 1,2,3,4,5
	// 就是find_if 第三个参数可调用对象（lambda） 返回true， find_if 就停止遍历
	// find_if 的调用返回一个迭代器，指向第一个满足条件的元素，如果这样的元素不存在，则这个迭代器就会指向mv2.end().
	if (re2 == mv2.end())
	{
		cout << "没有找到" << endl;
	}
	else
	{
		cout << "找到" << endl;
	}
	*/


	/************************************************************************/
	/* 总结： lambda 表达式可以让代码更加简洁，灵活，强大，提高开发效率，同时也提高了维护性
		更重要的是看项目中的代码更加方便！！！！
	*/
	/************************************************************************/


	int x = 3;
	auto f4 = [=]() mutable {
		x = 6;     // 原本是按值捕获的，不能修改，加上mutable后，就可以修改了,这里必须加上(),不管有没有参数
		return x;
	};

	std::function<int(int)> f5 = [](int c) {return c; };
	cout << f5(15) << endl;

	std::function<int(int)> f6 = std::bind(  // bind 第一个参数是函数指针， 第二参数开始就是真正的函数参数
		[](int v) {
		return v;
	}, 17
	);

	cout << f6(15) << endl;  // 这里不管给什么参数 ，输出的都是17， 因为内部已经定义了，但是不能不给参数


	using functype = int(*)(int);  // 定义一个函数指针类型
	functype fp = [](int v) {return v; };
	cout << fp(99) << endl;   // 99

	vector<int> mv = { 1,2,3,4,5,6,7,8, 9, 10};
	//for_each(mv.begin(), mv.end(), ass);  //ass函数中必须要 参数
	int re = 0;
	for_each(mv.begin(), mv.end(), [&re](int i) {
		cout << i << " "; 
		re += i;
	});
	cout << re << endl;
	
	vector<int> mv2 = { 1,2,3,4,5,6,7,8, 9, 10 };
	auto re2 = find_if(mv.begin(), mv.end(), [](int v) {
		cout << v << endl;
		if (v > 4) return true;  // 返回true，停止遍历
		return false;   // 只要返回fasle，那么find_if 就不停的遍历mv2 ，一直到返回true 或者遍历结束为止。
	});   //out : 1,2,3,4,5
	// 就是find_if 第三个参数可调用对象（lambda） 返回true， find_if 就停止遍历
	// find_if 的调用返回一个迭代器，指向第一个满足条件的元素，如果这样的元素不存在，则这个迭代器就会指向mv2.end().
	if (re2 == mv2.end())
	{
		cout << "没有找到" << endl;
	}
	else
	{
		cout << "找到" << endl;
	}

	return 0;
}